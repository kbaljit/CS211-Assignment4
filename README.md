# CS211-Assignment4
	Overview
	This assignment is designed to give us a better understanding about cache behavior. You will write a
	cache simulator using C programming language. The programs have to run on iLab machines. It’s
	also very important to follow the exact format as it’s explained in the description. Otherwise, you may
	lose up to 20% if your submission doesn’t follow the instructions.
	
	Understanding the Memory Access Traces
	We have provided you with three different memory trace files (mytrace.txt, trace1.txt and trace2.txt).
	These traces are the memory access (address) pattern of a program. By knowing the address of the
	memory locations during program execution you will be able to write a cache simulator. These two
	traces correspond to the sequence of memory accesses that are generated by the processor as it
	executes the stream of instructions from a particular program. For example, suppose the following:
	Currently, %esp = 0x00ffff40, and the processor executes the instruction:
	pushl %ebp
	Remember that the pushl instruction will copy the content of some register (in this case %ebp) to the
	memory location whose address is currently contained in %esp. (It also decrements %esp by 4, but that
	is not relevant to the memory system). This will result in the processor generating a W to address
	0x00ffff40. So these traces consist of 3 columns. First one is ip (instruction pointer), after that you can
	see R or W which means it is memory read or write and third column is the memory address.
	Note: In this assignment, you only need the memory address and R or W information. You do not need
	to keep or use ip addresses. 
	
	 Cache Simulator
	You will implement a Cache Simulator to evaluate different configurations of Caches, running it in
	different traces files. The followings are the requirements for the simulation:
	1. Simulate only one level cache: L1
	2. The size of the cache, associativity and blocksize are parameterizable.
	3. Replacement algorithm: FIFO https://en.wikipedia.org/wiki/Page_replacement_algorithm#First-in.
	2C_first-out or LRU https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU
	4. Implement both write through and write_back cache policies.
	 Invocation Interface
	Implement a program c-sim (the name of your binary file should be exactly this) that will simulate the
	operation of a cache. Your program c-sim should support the following usage interface:
	./c-sim <cache size> <associativity> <block size> <replacement_policy> <write_policy> <trace file>
	where:
	A) < cachesize > is the total size of the cache. This should be a power of 2. Also, it should always be
	true that
	< cachesize > = number of sets × < setsize > × < blocksize >.
	For direct-mapped caches, < setsize > = 1. For n − way associative caches, < setsize > = n.
	Given the above formula, together with < cachesize >, < setsize >, and < blocksize >, you can always
	compute the number of sets in your cache.
	B) < associativity > is one of:
	– direct - simulate a direct mapped cache.
	– assoc - simulate a fully associative cache.
	– assoc:n - simulate an n − way associative cache. n should be a power of 2.
	C) < blocksize > is an power of 2 integer that specifies the size of the cache block.
	D) <replacement_policy> is the LRU or FIFO.
	E) <write policy> is “wt” for write-through cache and “wb” for write-back cache.
	F) < tracefile > is the name of a file that contains a memory access traces.
	Your program should print out the number of memory reads, memory writes, cache hits, and cache
	misses. You should follow the format of the examples below (order of outputs, style and etc.).
	
	 Simulation Details
	1. (a) When your program first starts running, all entries in the cache should be invalid; (b) you can
	assume that the memory size is 232 . Therefore, memory address length is 32 bit. (c) the number of bits
	in the tag, cache address, and byte address are then determine by the cache size and block size; (d)
	Your simulator should simulate the operation of a cache according to the given parameters for the given
	trace; (e) at the end, it should print out the number of cache hits, cache misses, memory reads and
	memory writes.
	2. For write misses , assume the data brought in to the cache from memory (one read memory) before
	write take place.
